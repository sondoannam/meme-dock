import { databases } from '../config/appwrite';

/**
 * Request body interface for the increase usage count function
 */
interface IncreaseUsageCountRequest {
  /** Type of collection to update ('object', 'tag', or 'mood') */
  collectionType: 'object' | 'tag' | 'mood';
  
  /** Array of document IDs to update */
  ids: string[];
  
  /** Optional meme ID related to this usage event */
  memeId?: string;
  
  /** Type of event that triggered the usage count increase */
  eventType?: 'upload' | 'copy' | 'download';
  
  /** Optional user ID who performed the action */
  userId?: string;
}

/**
 * Result of a single document update operation
 */
interface UpdateResult {
  /** Document ID that was updated (or attempted to update) */
  id: string;
  
  /** Whether the update was successful */
  success: boolean;
  
  /** New usage count (if successful) */
  newCount?: number;
  
  /** Error message (if not successful) */
  error?: string;
}

/**
 * Collection mapping configuration
 */
interface CollectionConfig {
  /** Collection ID where the main documents are stored */
  collection: string;
  
  /** Collection ID where usage records are stored */
  usagesCollection: string;
  
  /** Field name for entity ID in the usage records */
  idField: string;
}

/**
 * Function to increase usage count for objects, tags, or moods
 * 
 * Environment variables:
 * - DATABASE_ID: Appwrite database ID
 * - OBJECT_COLLECTION_ID: Collection ID for objects
 * - TAG_COLLECTION_ID: Collection ID for tags
 * - MOOD_COLLECTION_ID: Collection ID for moods
 * - OBJECT_USAGES_COLLECTION_ID: Collection ID for object usage records
 * - TAG_USAGES_COLLECTION_ID: Collection ID for tag usage records
 * - MOOD_USAGES_COLLECTION_ID: Collection ID for mood usage records
 */
export default async function({ req, res, log }: { 
  req: { body: IncreaseUsageCountRequest }, 
  res: { 
    json: (data: any, status?: number) => any 
  }, 
  log: (...args: any[]) => void
}) {
  log('Increase usage count function started');

  try {
    // Validate request body
    const { collectionType, ids, memeId, eventType = 'upload', userId } = req.body || {};

    if (!collectionType || !ids || !Array.isArray(ids) || ids.length === 0) {
      return res.json({
        success: false,
        message: 'Invalid request. Required parameters: collectionType (string) and ids (array).',
      }, 400);
    }

    // Get collection IDs from environment variables
    const DATABASE_ID = process.env.DATABASE_ID;
    const collectionMap: Record<string, CollectionConfig> = {
      object: {
        collection: process.env.OBJECT_COLLECTION_ID || '',
        usagesCollection: process.env.OBJECT_USAGES_COLLECTION_ID || '',
        idField: 'objectId'
      },
      tag: {
        collection: process.env.TAG_COLLECTION_ID || '',
        usagesCollection: process.env.TAG_USAGES_COLLECTION_ID || '',
        idField: 'tagId'
      },
      mood: {
        collection: process.env.MOOD_COLLECTION_ID || '',
        usagesCollection: process.env.MOOD_USAGES_COLLECTION_ID || '',
        idField: 'moodId'
      }
    };

    // Validate collection type
    if (!collectionMap[collectionType]) {
      return res.json({
        success: false,
        message: `Invalid collection type: ${collectionType}. Supported types: object, tag, mood.`,
      }, 400);
    }

    // Get collection details
    const { collection, usagesCollection, idField } = collectionMap[collectionType];
    
    // Check if collection ID is available
    if (!DATABASE_ID || !collection || !usagesCollection) {
      return res.json({
        success: false,
        message: `Missing environment variables for ${collectionType} collections.`,
      }, 500);
    }

    // Create a date string for lastUsedAt
    const currentDate = new Date().toISOString();
    
    // Process each ID in parallel
    const results: UpdateResult[] = await Promise.all(
      ids.map(async (id) => {
        try {
          // 1. Get the current document
          const document = await databases.getDocument(DATABASE_ID, collection, id);
          
          // 2. Increment usage count and update lastUsedAt
          const currentCount = document.usageCount || 0;
          await databases.updateDocument(
            DATABASE_ID,
            collection,
            id,
            {
              usageCount: currentCount + 1,
              lastUsedAt: currentDate
            }
          );
          
          // 3. Add usage record if memeId is provided
          if (memeId && usagesCollection) {
            const usageRecord: Record<string, any> = {
              [idField]: id,
              memeId,
              eventType,
              timestamp: currentDate
            };
            
            // Add userId if provided
            if (userId) {
              usageRecord.userId = userId;
            }
            
            await databases.createDocument(
              DATABASE_ID,
              usagesCollection,
              'unique()',  // Let Appwrite generate a unique ID
              usageRecord
            );
          }
          
          return {
            id,
            success: true,
            newCount: currentCount + 1
          };
        } catch (err: any) {
          log(`Error updating ${collectionType} with ID ${id}:`, err);
          return {
            id,
            success: false,
            error: err.message
          };
        }
      })
    );
    
    // Count successful and failed operations
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => !r.success).length;
    
    return res.json({
      success: true,
      message: `Usage count increased successfully for ${successful} ${collectionType}(s). Failed: ${failed}.`,
      data: {
        results,
        successful,
        failed,
        total: ids.length
      },
    });
    
  } catch (err: any) {
    log('Error in increase usage count function:', err);
    return res.json({
      success: false,
      message: 'Error increasing usage count',
      error: err.message
    }, 500);
  }
}
